<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WomenTalk Decoder GPT (Satirical)</title>
    <script src="https://cdn.tailwindcss.com/"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: #111827; /* Dark charcoal background */
            min-height: 100vh;
        }
        .container {
            max-width: 900px;
        }
        .header {
            background: linear-gradient(135deg, #27c390 0%, #00937b 100%); /* Groq-like Teal/Green Gradient */
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .card {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.15);
            background-color: #1f2937; /* Slightly lighter dark background for cards */
            border: 1px solid #4b5563;
        }
        .result-section h3 {
            font-size: 1.125rem;
            font-weight: 700;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
            border-bottom: 2px solid #27c390; /* Teal/Green border */
            padding-bottom: 0.25rem;
            color: #d1d5db; /* Light gray text */
        }
        .output-text {
            color: #e5e7eb; /* Off-white text */
        }
        .loading-spinner {
            border-top-color: #27c390;
            border-left-color: #27c390;
        }
        .groq-disclaimer {
            font-size: 0.8rem;
            color: #10b981; /* Green text */
            margin-top: 0.5rem;
            font-style: italic;
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div id="app" class="container mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-extrabold header leading-tight">
                Sangela (WomenTalk Decoder GPT)
            </h1>
            <p class="text-gray-400 mt-2 italic">
                A highly stereotypical and satirical translator for relationship subtext.
            </p>
            <p class="groq-disclaimer">
                (Powered by the Groq API, using the supported **Llama-3.3-70b-versatile** model for extreme speed.)
            </p>
        </header>

        <div class="card p-6 rounded-xl mb-8">
            <h2 class="text-xl font-bold text-white mb-4">Input: The Cryptic Message</h2>
            
            <!-- Voice Input Container -->
            <div class="relative flex items-center">
                <textarea id="userInput" rows="4" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:ring-green-500 focus:border-green-500 transition duration-150 resize-none pr-12" placeholder="e.g., 'I'm fine.' or 'We never talk about anything important.'"></textarea>
                
                <button id="micButton" class="absolute right-3 top-3 p-2 rounded-full bg-gray-600 text-white hover:bg-gray-500 transition duration-150 disabled:opacity-50" title="Voice Input (Speech-to-Text)">
                    <!-- Mic icon (Lucide Microphone SVG) -->
                    <svg id="micIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5">
                        <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="22"/>
                    </svg>
                </button>
            </div>

            <div class="flex justify-end mt-4">
                <button id="translateButton" class="px-6 py-3 bg-green-600 text-white font-bold rounded-full hover:bg-green-700 transition duration-200 focus:outline-none focus:ring-4 focus:ring-green-500 focus:ring-opacity-50 disabled:opacity-50" onclick="translateTalk()">
                    Decode the Subtext
                </button>
            </div>
        </div>

        <div id="loading" class="text-center p-6" style="display: none;">
            <div class="loading-spinner inline-block w-8 h-8 border-4 border-gray-600 border-solid rounded-full animate-spin"></div>
            <p class="text-gray-400 mt-2">Analyzing emotional algorithms at warp speed...</p>
        </div>

        <div id="results" class="card p-6 rounded-xl" style="display: none;">
            <h2 class="text-2xl font-bold text-white mb-4 border-b pb-2 border-gray-600">Decoder Output</h2>
            <div id="responseText" class="output-text space-y-4">
                <!-- Translation results will be injected here -->
            </div>
        </div>

        <!-- Hidden Modal for API Error/Warning -->
        <div id="errorModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50 transition-opacity duration-300 opacity-0 pointer-events-none">
            <div class="bg-red-900 p-6 rounded-xl shadow-2xl max-w-sm w-full transform -translate-y-4 transition-transform duration-300">
                <h3 class="text-xl font-bold text-red-300 mb-4">Transmission Error</h3>
                <p id="errorMessage" class="text-red-100">An unexpected error occurred during decoding. Please try again.</p>
                <button class="mt-4 px-4 py-2 bg-red-700 text-white font-semibold rounded-lg hover:bg-red-800" onclick="closeModal('errorModal')">Dismiss</button>
            </div>
        </div>

    </div>

    <script type="module">
        // --- SECURITY AND MODEL NOTE ---
        const apiUrl = 'https://groq-api-proxy.cwbernards.workers.dev'; 
        const groqModel = 'llama-3.3-70b-versatile'; 

        const systemInstructionText = `
            Act as WomenTalkDecoderGPT. Your job is to help men understand the emotional meaning, subtext, and underlying needs behind messages they hear in relationships. When I give you something a woman said, interpret it using principles from relationship communication, emotional psychology, and conflict-resolution (e.g., Gottman, NVC). To make it funny and adhere to the user's request for a joke app, you MUST rely heavily on stereotypes and only consider the extreme possibilities.

            For every message, you MUST format your response strictly using the following Markdown headers and structure:

            ### 1. The Literal Meaning (The Surface)
            [Explanation of what was literally said.]

            ### 2. The Man Translation (The Subtext)
            [Clear, direct, often exaggerated and stereotypical wording that a man might better understand. If possible, give 2 potential translations labeled: 1) Best case 2) Worst case]

            ### 3. The Suggested Response (The Fix)
            [A suggested healthy, respectful, but slightly humorously pragmatic way to respond, focusing on resolving the underlying emotional need.]
        `;


        const userInput = document.getElementById('userInput');
        const translateButton = document.getElementById('translateButton');
        const loadingDiv = document.getElementById('loading');
        const resultsDiv = document.getElementById('results');
        const responseTextDiv = document.getElementById('responseText');
        const errorModal = document.getElementById('errorModal');
        const errorMessageDiv = document.getElementById('errorMessage');
        
        // Voice Input Elements
        const micButton = document.getElementById('micButton');
        const micIcon = document.getElementById('micIcon');
        let recognition = null;
        let isRecording = false;

        // --- Voice Input Setup (Web Speech API) ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = false; // Stop after first utterance
            recognition.interimResults = false;
            recognition.lang = 'en-US';

            recognition.onstart = () => {
                isRecording = true;
                micIcon.classList.add('text-red-400', 'animate-pulse'); // Visual cue for recording
                micButton.title = "Recording... Click to stop.";
            };

            recognition.onend = () => {
                isRecording = false;
                micIcon.classList.remove('text-red-400', 'animate-pulse');
                micButton.title = "Voice Input (Speech-to-Text)";
                micButton.disabled = false; // Ensure button is re-enabled
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                userInput.value = transcript;
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                showError(`Voice Input Error: ${event.error}. Please ensure microphone permission is granted.`);
                recognition.onend(); // Clean up state
            };
            
            micButton.onclick = toggleVoiceInput;

        } else {
            // Disable button if API not supported
            micButton.disabled = true;
            micButton.title = "Voice Input Not Supported in this browser.";
        }

        /**
         * Starts or stops voice recognition.
         */
        function toggleVoiceInput() {
            if (isRecording) {
                recognition.stop();
                micButton.disabled = true; 
            } else {
                try {
                    userInput.value = ''; // Clear previous input
                    recognition.start();
                } catch (e) {
                    console.error("Error starting recognition:", e);
                    showError("Could not start microphone. Check browser permissions.");
                }
            }
        }
        // --- End Voice Input Setup ---

        /**
         * Parses the model's Markdown response and formats it into HTML.
         * The model is instructed to use ### headers, which we'll convert to our styled divs.
         * @param {string} text The raw text response from the API.
         * @returns {string} Styled HTML content.
         */
        function parseAndStyleResponse(text) {
            const sections = text.split('###').filter(s => s.trim().length > 0);
            let html = '';

            sections.forEach(section => {
                // Split the header from the content. Example: "1. The Literal Meaning (The Surface)\nContent..."
                const parts = section.trim().split('\n');
                if (parts.length < 2) return;

                const title = parts[0].trim();
                const content = parts.slice(1).join('\n').trim();
                
                // Convert Markdown list items to HTML list items
                const contentHtml = content
                    .replace(/^\s*\-\s/gm, '<li>')
                    .replace(/\* /gm, '<li>')
                    .replace(/\n\s*<li>/g, '</li><li>') // handles multiline lists
                    .replace(/<\/\s*li>\s*$/g, ''); // cleanup trailing </li>

                const finalContent = contentHtml.startsWith('<li>') ? 
                    `<ul class="list-disc ml-6">${contentHtml}</ul>` : 
                    `<p>${contentHtml.replace(/\n/g, '<br>')}</p>`;

                html += `
                    <div class="result-section">
                        <h3 class="text-lg font-semibold text-green-400">${title}</h3>
                        ${finalContent}
                    </div>
                `;
            });
            return html;
        }

        /**
         * Handles the API call with exponential backoff for resilience.
         * @param {number} attempt The current retry attempt (starts at 1).
         */
        async function fetchWithBackoff(attempt = 1) {
            const maxRetries = 5;
            const delay = Math.pow(2, attempt) * 1000; // 2s, 4s, 8s, ...

            const userQuery = userInput.value.trim();

            if (!userQuery) {
                showError("Please enter a message to decode.");
                return;
            }
            
            // The Groq API uses the standard OpenAI chat completions format.
            const payload = {
                model: groqModel,
                messages: [
                    { role: "system", content: systemInstructionText },
                    { role: "user", content: userQuery }
                ],
                // Add any other desired parameters for the Groq API here, e.g., max_tokens, temperature
            };

            try {
                // Check if the URL is still the placeholder (no longer an issue here)
                if (apiUrl === 'REPLACE_WITH_YOUR_DEPLOYED_WORKER_URL') {
                    throw new Error("API URL is not configured. Please replace the placeholder 'REPLACE_WITH_YOUR_DEPLOYED_WORKER_URL' with your Worker's URL.");
                }

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (response.status === 429 && attempt < maxRetries) {
                    // Too Many Requests, retry with backoff
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return fetchWithBackoff(attempt + 1);
                }

                if (!response.ok) {
                    // Try to parse error details from the proxy/API
                    const errorDetails = await response.json().catch(() => ({}));
                    let errorMsg = `Proxy/API failed. Status: ${response.status}.`;
                    
                    if (response.status === 404) {
                        errorMsg += " Double-check the Worker URL is correct.";
                    } else if (response.status === 500) {
                        // This usually means the worker failed internally (e.g., missing API key or bad Groq request)
                         errorMsg += ` Worker Error. Details: ${errorDetails.error?.message || 'Check your Cloudflare Worker logs for details.'}`;
                    } else {
                        errorMsg += ` Details: ${errorDetails.error?.message || 'Unknown error.'}`;
                    }
                    
                    throw new Error(errorMsg);
                }
                
                // Assuming the proxy returns a simple JSON object compatible with the OpenAI format:
                // { choices: [{ message: { content: "..." } }] }
                const result = await response.json();
                const text = result.choices?.[0]?.message?.content;

                if (text) {
                    responseTextDiv.innerHTML = parseAndStyleResponse(text);
                } else {
                    throw new Error("Proxy response was empty or malformed.");
                }

            } catch (error) {
                console.error("Fetch error:", error);
                showError(`Failed to decode the message. ${error.message}`);
            }
        }

        /**
         * Main function to trigger the translation process.
         */
        window.translateTalk = async function() {
            resultsDiv.style.display = 'none';
            responseTextDiv.innerHTML = '';
            showLoading(true);

            await fetchWithBackoff();

            showLoading(false);
            if (responseTextDiv.innerHTML) {
                resultsDiv.style.display = 'block';
            }
        }

        /**
         * Utility function to control the loading state.
         * @param {boolean} isLoading
         */
        function showLoading(isLoading) {
            translateButton.disabled = isLoading;
            loadingDiv.style.display = isLoading ? 'block' : 'none';
            userInput.disabled = isLoading;
            if (isLoading) {
                resultsDiv.style.display = 'none';
            }
        }
        
        /**
         * Utility function to show the custom error modal.
         * @param {string} message
         */
        function showError(message) {
            errorMessageDiv.textContent = message;
            errorModal.classList.remove('opacity-0', 'pointer-events-none');
            errorModal.querySelector('div').classList.remove('-translate-y-4');
        }

        /**
         * Utility function to close the custom modal.
         * @param {string} id The ID of the modal to close.
         */
        window.closeModal = function(id) {
            const modal = document.getElementById(id);
            modal.classList.add('opacity-0', 'pointer-events-none');
            modal.querySelector('div').classList.add('-translate-y-4');
        }

        // Initialize state
        showLoading(false);
    </script>

</body>
</html>
